###############################################################################
#
# IAR C/C++ Compiler V6.10.2.50871/W32 for MSP430         30/Oct/2014  18:13:08
# Copyright 1996-2014 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.10
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        E:\Fall 14\ECE 306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\switch.c
#    Command line  =  
#        "E:\Fall 14\ECE 306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\switch.c" -lC
#        "E:\Fall 14\ECE 306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\Debug\List\"
#        -o "E:\Fall 14\ECE 306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\Debug\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR5739__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.0\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -Ol --multiplier=32
#        --multiplier_location=4C0 --hw_workaround=CPU40 --hw_workaround=CPU39
#        --code_model=large
#    List file     =  
#        E:\Fall 14\ECE
#        306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\Debug\List\switch.lst
#    Object file   =  
#        E:\Fall 14\ECE
#        306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\Debug\Obj\switch.r43
#
###############################################################################

E:\Fall 14\ECE 306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\switch.c
      1          //------------------------------------------------------------------------------
      2          //  File Name : switch.c
      3          //
      4          //  Description: This file contains the switch control functions
      5          //
      6          //  Mattia Muller
      7          //  Sep 2014
      8          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1)
      9          //------------------------------------------------------------------------------
     10          
     11          
     12          #include "macros.h"
     13          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x23a
   \   union <unnamed> _A_PBIE_L
   \                     _A_PBIE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x23c
   \   union <unnamed> _A_PBIFG_L
   \                     _A_PBIFG_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x23e
   \   unsigned short volatile P4IV
   \                     P4IV:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x322
   \   union <unnamed> _A_PJOUT_L
   \                     _A_PJOUT_L:
   \   000000                DS8 2
     14          #include "functions.h"
     15          
     16          extern unsigned char black_space;
     17          extern char *display_1;
     18          extern char *display_2;

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          volatile unsigned char okay_to_look_at_switch1 = NOT_OKAY;
   \                     okay_to_look_at_switch1:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     20          volatile unsigned char okay_to_look_at_switch2 = NOT_OKAY;
   \                     okay_to_look_at_switch2:
   \   000000                DS8 1

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     21          volatile unsigned char sw1_position = RELEASED;
   \                     sw1_position:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for sw1_position>`

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     22          volatile unsigned char sw2_position = RELEASED;
   \                     sw2_position:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for sw2_position>`

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     23          volatile unsigned int count_debounce_SW1 = SET_0;
   \                     count_debounce_SW1:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     24          volatile unsigned int count_debounce_SW2 = SET_0;
   \                     count_debounce_SW2:
   \   000000                DS8 2
     25          extern unsigned char current_step;
     26          extern volatile unsigned char stop, straight_direction, sample, what_to_do, what_to_do_movement;
     27          extern volatile int time_limit;
     28          extern unsigned char right_wheel_count, left_wheel_count;
     29          
     30          //=========================================================================== 
     31          // Function name: Switch1_Process
     32          //
     33          // Description: This function handles the detection of SW1
     34          //
     35          // Passed : no variables passed
     36          // Locals: no variables declared
     37          // Returned: no values returned
     38          // Globals: none
     39          //
     40          // Author: Mattia Muller
     41          // Date: Sept 2013
     42          // Compiler: Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1) //===========================================================================

   \                                 In  segment CODE, align 2
     43          void Switch1_Process(void){
   \                     Switch1_Process:
     44          	if (!sw1_position){
   \   000000   C293....     CMP.B   #0x0, &sw1_position
   \   000004   0A20         JNE     ??Switch1_Process_0
     45                      sw1_position = RELEASED;
   \   000006   D243....     MOV.B   #0x1, &sw1_position
     46                       okay_to_look_at_switch1 = NOT_OKAY;
   \   00000A   C243....     MOV.B   #0x0, &okay_to_look_at_switch1
     47                       PJOUT &=~LED3;
   \   00000E   A2C22203     BIC.W   #0x4, &0x322
     48                       current_step = SET_0;
   \   000012   C243....     MOV.B   #0x0, &current_step
     49                      do_stuff();              
   \   000016   ........     CALLA   #do_stuff
     50           	}
     51          }
   \                     ??Switch1_Process_0:
   \   00001A   1001         RETA
   \   00001C                REQUIRE _A_PJOUT_L
     52          
     53          
     54          //=========================================================================== 
     55          // Function name: Switch2_Process
     56          //
     57          // Description: This function handles the detection of SW2
     58          //
     59          // Passed : no variables passed
     60          // Locals: no variables declared
     61          // Returned: no values returned
     62          // Globals: none
     63          //
     64          // Author: Mattia Muller
     65          // Date: Sept 2013
     66          // Compiler: Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1) //===========================================================================

   \                                 In  segment CODE, align 2
     67          void Switch2_Process(void){
   \                     Switch2_Process:
     68          		if (!sw2_position){
   \   000000   C293....     CMP.B   #0x0, &sw2_position
   \   000004   0A20         JNE     ??Switch2_Process_0
     69                      sw2_position = RELEASED;
   \   000006   D243....     MOV.B   #0x1, &sw2_position
     70                       okay_to_look_at_switch2 = NOT_OKAY;
   \   00000A   C243....     MOV.B   #0x0, &okay_to_look_at_switch2
     71                       PJOUT &=~LED3;
   \   00000E   A2C22203     BIC.W   #0x4, &0x322
     72                       current_step++;   
   \   000012   D253....     ADD.B   #0x1, &current_step
     73                      do_stuff();              
   \   000016   ........     CALLA   #do_stuff
     74                       
     75           	}
     76          }
   \                     ??Switch2_Process_0:
   \   00001A   1001         RETA
   \   00001C                REQUIRE _A_PJOUT_L
     77          
     78          //=========================================================================== 
     79          // Function name: Switches_Process
     80          //
     81          // Description: This function handles the detection of SW1 and SW2
     82          //
     83          // Passed : no variables passed
     84          // Locals: no variables declared
     85          // Returned: no values returned
     86          // Globals: none
     87          //
     88          // Author: Mattia Muller
     89          // Date: Sept 2013
     90          // Compiler: Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1) //===========================================================================
     91          //******************************************************************************
     92          //------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2
     93          void Switches_Process(void){
   \                     Switches_Process:
     94           Switch1_Process();
   \   000000   ........     CALLA   #Switch1_Process
     95           Switch2_Process();
   \   000004   ........     BRA     #Switch2_Process
     96          } 
     97          //------------------------------------------------------------------------------
     98          //******************************************************************************
     99          
    100          
    101          // timerA0-1,2,overflow Interrupt Vector (TAIV) handler
    102          #pragma vector=PORT4_VECTOR

   \                                 In  segment ISR_CODE, align 2
    103          __interrupt void PORT4_VECTOR_ISR(void){
   \                     PORT4_VECTOR_ISR:
   \   000000   0F12         PUSH.W  R15
    104          
    105            switch(P4IV)
   \   000002   1F423E02     MOV.W   &0x23e, R15
   \   000006   2F83         SUB.W   #0x2, R15
   \   000008   0324         JEQ     ??PORT4_VECTOR_ISR_1
   \   00000A   2F83         SUB.W   #0x2, R15
   \   00000C   0C24         JEQ     ??PORT4_VECTOR_ISR_2
   \   00000E   153C         JMP     ??PORT4_VECTOR_ISR_0
    106              {
    107                case P4IV_P4IFG0:        
    108                  disableInput();               
   \                     ??PORT4_VECTOR_ISR_1:
   \   000010   ........     CALLA   #disableInput
    109                  sw1_position = RELEASED;
   \   000014   D243....     MOV.B   #0x1, &sw1_position
    110                  okay_to_look_at_switch1 = OKAY;
   \   000018   D243....     MOV.B   #0x1, &okay_to_look_at_switch1
    111                  count_debounce_SW1 = SET_0;
   \   00001C   8243....     MOV.W   #0x0, &count_debounce_SW1
    112                  PJOUT |=LED3;
   \   000020   A2D22203     BIS.W   #0x4, &0x322
    113                  break;
   \   000024   0A3C         JMP     ??PORT4_VECTOR_ISR_0
    114                    
    115                case P4IV_P4IFG1:
    116                  disableInput();               
   \                     ??PORT4_VECTOR_ISR_2:
   \   000026   ........     CALLA   #disableInput
    117                  sw2_position = RELEASED;
   \   00002A   D243....     MOV.B   #0x1, &sw2_position
    118                  okay_to_look_at_switch2 = OKAY;
   \   00002E   D243....     MOV.B   #0x1, &okay_to_look_at_switch2
    119                  count_debounce_SW2 = SET_0;
   \   000032   8243....     MOV.W   #0x0, &count_debounce_SW2
    120                  PJOUT |=LED3;
   \   000036   A2D22203     BIS.W   #0x4, &0x322
    121                default:
    122                  break;
    123              }  
    124            
    125          
    126          }
   \                     ??PORT4_VECTOR_ISR_0:
   \   00003A   3F41         POP.W   R15
   \   00003C   0013         RETI
   \   00003E                REQUIRE _A_PJOUT_L
   \   00003E                REQUIRE P4IV
    127          // timerA0
    128          //=============================================================================
    129          
    130          
    131          //=========================================================================== 
    132          // Function name: disableInput
    133          //
    134          // Description: This function disables of SW1 and SW2
    135          //
    136          // Passed : no variables passed
    137          // Locals: no variables declared
    138          // Returned: no values returned
    139          // Globals: none
    140          //
    141          // Author: Mattia Muller
    142          // Date: Sept 2013
    143          // Compiler: Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1) //===========================================================================
    144          //******************************************************************************
    145          //------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2
    146          void disableInput(void)
   \                     disableInput:
    147          {
    148          
    149            P4IE &= ~(SW1 | SW2);                     // P4.0 interrupt disabled
   \   000000   F2F0FC003B02 AND.B   #0xfc, &0x23b
    150            P4IFG = SET_0;                            // P4 IFG cleared  
   \   000006   C2433D02     MOV.B   #0x0, &0x23d
    151          }
   \   00000A   1001         RETA
   \   00000C                REQUIRE _A_PBIE_L
   \   00000C                REQUIRE _A_PBIFG_L
    152          
    153          //=========================================================================== 
    154          // Function name: enableInput
    155          //
    156          // Description: This function enables SW1 and SW2
    157          //
    158          // Passed : no variables passed
    159          // Locals: no variables declared
    160          // Returned: no values returned
    161          // Globals: none
    162          //
    163          // Author: Mattia Muller
    164          // Date: Sept 2013
    165          // Compiler: Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1) //===========================================================================
    166          //******************************************************************************
    167          //------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2
    168          void enableInput(void)
   \                     enableInput:
    169          {
    170          
    171            P4IE |= (SW1 | SW2);                     // P4.0 interrupt disabled
   \   000000   F2D003003B02 BIS.B   #0x3, &0x23b
    172            P4IFG = SET_0;                           // P4 IFG cleared  
   \   000006   C2433D02     MOV.B   #0x0, &0x23d
    173          }
   \   00000A   1001         RETA
   \   00000C                REQUIRE _A_PBIE_L
   \   00000C                REQUIRE _A_PBIFG_L
    174          
    175          
    176          //=========================================================================== 
    177          // Function name: do_stuff
    178          //
    179          // Description: Do stuff when SW1 or SW2 are pressed
    180          //
    181          // Passed : no variables passed
    182          // Locals: no variables declared
    183          // Returned: no values returned
    184          // Globals: none
    185          //
    186          // Author: Mattia Muller
    187          // Date: Sept 2013
    188          // Compiler: Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1) //===========================================================================
    189          //******************************************************************************
    190          //------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2
    191          void do_stuff(void){
   \                     do_stuff:
    192            switch(what_to_do){
   \   000000   5E42....     MOV.B   &what_to_do, R14
   \   000004   6E83         SUB.B   #0x2, R14
   \   000006   3A24         JEQ     ??do_stuff_3
   \   000008   7E800600     SUB.B   #0x6, R14
   \   00000C   0C24         JEQ     ??do_stuff_4
   \   00000E   5E83         SUB.B   #0x1, R14
   \   000010   1624         JEQ     ??do_stuff_5
   \   000012   5E83         SUB.B   #0x1, R14
   \   000014   1224         JEQ     ??do_stuff_6
   \   000016   7E800300     SUB.B   #0x3, R14
   \   00001A   2E24         JEQ     ??do_stuff_7
   \   00001C   5E83         SUB.B   #0x1, R14
   \   00001E   3B24         JEQ     ??do_stuff_2
   \   000020   5E83         SUB.B   #0x1, R14
   \   000022   3924         JEQ     ??do_stuff_2
   \   000024   1001         RETA
    193          		case CALIBRATE:
    194                            lcd_out("              ", LCD_LINE_2);
   \                     ??do_stuff_4:
   \   000026   7D40C000     MOV.B   #0xc0, R13
   \   00002A   3C40....     MOV.W   #`?<Constant "              ">`, R12
   \   00002E   ........     CALLA   #lcd_out
    195                                 IR_calibration(current_step);
   \   000032   5C42....     MOV.B   &current_step, R12
   \   000036   ........     BRA     #IR_calibration
    196                                 //char* ascii_value = itoa(current_step);            
    197                                    
    198                                 //lcd_out(ascii_value, LCD_LINE_2);     
    199                          break;
    200          		case STRAIGHT: // 1250 msec 
    201          			STRAIGHT_TIME_Process();
   \                     ??do_stuff_6:
   \   00003A   ........     BRA     #STRAIGHT_TIME_Process
    202          		break;
    203                          case PROJECT_05: // 1250 msec 
    204                                  fifty_msec_sleep_A1(SET_10);
   \                     ??do_stuff_5:
   \   00003E   3C400A00     MOV.W   #0xa, R12
   \   000042   ........     CALLA   #fifty_msec_sleep_A1
    205                                  stop = OFF;
   \   000046   C243....     MOV.B   #0x0, &stop
    206                                  straight_direction = FORWARD;
   \   00004A   D243....     MOV.B   #0x1, &straight_direction
    207                                  current_step = SET_0;
   \   00004E   C243....     MOV.B   #0x0, &current_step
    208                                  time_limit = SET_NEG_1;
   \   000052   B243....     MOV.W   #0xffff, &time_limit
    209          			what_to_do = PROJECT_05;
   \   000056   F2400900.... MOV.B   #0x9, &what_to_do
    210                                  left_wheel_count = LEFT_WHEEL_COUNT;
   \   00005C   F2401E00.... MOV.B   #0x1e, &left_wheel_count
    211           			right_wheel_count = RIGHT_WHEEL_COUNT;
   \   000062   F2401100.... MOV.B   #0x11, &right_wheel_count
    212                                  what_to_do_movement = STRAIGHT;
   \   000068   F2400A00.... MOV.B   #0xa, &what_to_do_movement
    213                                  sample = ON;
   \   00006E   D243....     MOV.B   #0x1, &sample
    214                                  black_space = OFF;
   \   000072   C243....     MOV.B   #0x0, &black_space
    215          		break;
   \   000076   1001         RETA
    216                          case THUMB_WHEEL: // 1250 msec 
    217          			CLOCK_TIME_Process();
   \                     ??do_stuff_7:
   \   000078   ........     BRA     #CLOCK_TIME_Process
    218          		break;
    219          		case SERIAL: 
    220                            if (current_step == SET_0) {
   \                     ??do_stuff_3:
   \   00007C   C293....     CMP.B   #0x0, &current_step
   \   000080   0420         JNE     ??do_stuff_8
    221                                 uart_send_byte('N');
   \   000082   7C404E00     MOV.B   #0x4e, R12
   \   000086   ........     BRA     #uart_send_byte
    222                            } else {
    223                              lcd_out("               ",LCD_LINE_2);
   \                     ??do_stuff_8:
   \   00008A   7D40C000     MOV.B   #0xc0, R13
   \   00008E   3C40....     MOV.W   #`?<Constant "               ">`, R12
   \   000092   ........     CALLA   #lcd_out
    224                            }
    225          		break;
    226          		case FIGURE_8: // 1250 msec 
    227          		 	//FIGURE_8_Process();
    228          		break;
    229          		case TRIANGLE: // 1250 msec 
    230          			//TRIANGLE_Process();
    231          		break;
    232          		default: 
    233          		 	//Default_Process();
    234          		break;
    235          		}
    236            
    237            
    238          }
   \                     ??do_stuff_2:
   \   000096   1001         RETA

   \                                 In  segment INTVEC, offset 0x40, root
   \                     `??PORT4_VECTOR_ISR??INTVEC 64`:
   \   000040   ....         DC16    PORT4_VECTOR_ISR

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for sw1_position>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for sw2_position>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "              ">`:
   \   000000   202020202020 DC8 "              "
   \            202020202020
   \            202000      

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "               ">`:
   \   000000   202020202020 DC8 "               "
   \            202020202020
   \            20202000    

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      6   PORT4_VECTOR_ISR
        6   -> disableInput
      4   Switch1_Process
        4   -> do_stuff
      4   Switch2_Process
        4   -> do_stuff
      4   Switches_Process
        4   -> Switch1_Process
        4   -> Switch2_Process
      4   disableInput
      4   do_stuff
        4   -> CLOCK_TIME_Process
        4   -> IR_calibration
        4   -> STRAIGHT_TIME_Process
        4   -> fifty_msec_sleep_A1
        4   -> lcd_out
        4   -> uart_send_byte
      4   enableInput


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant "               ">
      15  ?<Constant "              ">
       1  ?<Initializer for sw1_position>
       1  ?<Initializer for sw2_position>
       2  ??PORT4_VECTOR_ISR??INTVEC 64
       2  P4IV
      62  PORT4_VECTOR_ISR
      28  Switch1_Process
      28  Switch2_Process
       8  Switches_Process
       2  _A_PBIE_L
       2  _A_PBIFG_L
       2  _A_PJOUT_L
       2  count_debounce_SW1
       2  count_debounce_SW2
      12  disableInput
     152  do_stuff
      12  enableInput
       1  okay_to_look_at_switch1
       1  okay_to_look_at_switch2
       1  sw1_position
       1  sw2_position

 
 240 bytes in segment CODE
   8 bytes in segment DATA16_AN
  31 bytes in segment DATA16_C
   2 bytes in segment DATA16_I
   2 bytes in segment DATA16_ID
   6 bytes in segment DATA16_Z
   2 bytes in segment INTVEC
  62 bytes in segment ISR_CODE
 
 302 bytes of CODE  memory
  33 bytes of CONST memory (+ 2 bytes shared)
   8 bytes of DATA  memory (+ 8 bytes shared)

Errors: none
Warnings: none
