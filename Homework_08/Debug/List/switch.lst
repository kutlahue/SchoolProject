###############################################################################
#
# IAR C/C++ Compiler V6.10.2.50871/W32 for MSP430         31/Oct/2014  16:26:21
# Copyright 1996-2014 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.10
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        E:\Fall 14\ECE 306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\switch.c
#    Command line  =  
#        "E:\Fall 14\ECE 306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\switch.c" -lC
#        "E:\Fall 14\ECE 306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\Debug\List\"
#        -o "E:\Fall 14\ECE 306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\Debug\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR5739__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.0\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -Ol --multiplier=32
#        --multiplier_location=4C0 --hw_workaround=CPU40 --hw_workaround=CPU39
#        --code_model=large
#    List file     =  
#        E:\Fall 14\ECE
#        306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\Debug\List\switch.lst
#    Object file   =  
#        E:\Fall 14\ECE
#        306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\Debug\Obj\switch.r43
#
###############################################################################

E:\Fall 14\ECE 306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\switch.c
      1          //------------------------------------------------------------------------------
      2          //  File Name : switch.c
      3          //
      4          //  Description: This file contains the switch control functions
      5          //
      6          //  Mattia Muller
      7          //  Sep 2014
      8          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1)
      9          //------------------------------------------------------------------------------
     10          
     11          
     12          #include "macros.h"
     13          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x23a
   \   union <unnamed> _A_PBIE_L
   \                     _A_PBIE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x23c
   \   union <unnamed> _A_PBIFG_L
   \                     _A_PBIFG_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x23e
   \   unsigned short volatile P4IV
   \                     P4IV:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x322
   \   union <unnamed> _A_PJOUT_L
   \                     _A_PJOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5ec
   \   union <unnamed> _A_UCA1RXBUF_L
   \                     _A_UCA1RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5fa
   \   union <unnamed> _A_UCA1IE_L
   \                     _A_UCA1IE_L:
   \   000000                DS8 2
     14          #include "functions.h"
     15          
     16          extern unsigned char black_space;
     17          extern char *display_1;
     18          extern char *display_2;

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          volatile unsigned char okay_to_look_at_switch1 = NOT_OKAY;
   \                     okay_to_look_at_switch1:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     20          volatile unsigned char okay_to_look_at_switch2 = NOT_OKAY;
   \                     okay_to_look_at_switch2:
   \   000000                DS8 1

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     21          volatile unsigned char sw1_position = RELEASED;
   \                     sw1_position:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for sw1_position>`

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     22          volatile unsigned char sw2_position = RELEASED;
   \                     sw2_position:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for sw2_position>`

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     23          volatile unsigned int count_debounce_SW1 = SET_0;
   \                     count_debounce_SW1:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     24          volatile unsigned int count_debounce_SW2 = SET_0;
   \                     count_debounce_SW2:
   \   000000                DS8 2
     25          extern unsigned char current_step;
     26          extern volatile unsigned char stop, straight_direction, sample, what_to_do, what_to_do_movement;
     27          extern volatile int time_limit;
     28          extern unsigned char right_wheel_count, left_wheel_count;
     29          
     30          extern volatile unsigned int cpu_rx_ring_wr, cpu_rx_ring_rd, cpu_tx_ring_wr, cpu_tx_ring_rd;
     31          
     32          //=========================================================================== 
     33          // Function name: Switch1_Process
     34          //
     35          // Description: This function handles the detection of SW1
     36          //
     37          // Passed : no variables passed
     38          // Locals: no variables declared
     39          // Returned: no values returned
     40          // Globals: none
     41          //
     42          // Author: Mattia Muller
     43          // Date: Sept 2013
     44          // Compiler: Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1) //===========================================================================

   \                                 In  segment CODE, align 2
     45          void Switch1_Process(void){
   \                     Switch1_Process:
     46          	if (!sw1_position){
   \   000000   C293....     CMP.B   #0x0, &sw1_position
   \   000004   0A20         JNE     ??Switch1_Process_0
     47                      sw1_position = RELEASED;
   \   000006   D243....     MOV.B   #0x1, &sw1_position
     48                       okay_to_look_at_switch1 = NOT_OKAY;
   \   00000A   C243....     MOV.B   #0x0, &okay_to_look_at_switch1
     49                       PJOUT &=~LED3;
   \   00000E   A2C22203     BIC.W   #0x4, &0x322
     50                       current_step = SET_0;
   \   000012   C243....     MOV.B   #0x0, &current_step
     51                      do_stuff();              
   \   000016   ........     CALLA   #do_stuff
     52           	}
     53          }
   \                     ??Switch1_Process_0:
   \   00001A   1001         RETA
   \   00001C                REQUIRE _A_PJOUT_L
     54          
     55          
     56          //=========================================================================== 
     57          // Function name: Switch2_Process
     58          //
     59          // Description: This function handles the detection of SW2
     60          //
     61          // Passed : no variables passed
     62          // Locals: no variables declared
     63          // Returned: no values returned
     64          // Globals: none
     65          //
     66          // Author: Mattia Muller
     67          // Date: Sept 2013
     68          // Compiler: Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1) //===========================================================================

   \                                 In  segment CODE, align 2
     69          void Switch2_Process(void){
   \                     Switch2_Process:
     70          		if (!sw2_position){
   \   000000   C293....     CMP.B   #0x0, &sw2_position
   \   000004   0A20         JNE     ??Switch2_Process_0
     71                      sw2_position = RELEASED;
   \   000006   D243....     MOV.B   #0x1, &sw2_position
     72                       okay_to_look_at_switch2 = NOT_OKAY;
   \   00000A   C243....     MOV.B   #0x0, &okay_to_look_at_switch2
     73                       PJOUT &=~LED3;
   \   00000E   A2C22203     BIC.W   #0x4, &0x322
     74                       current_step++;   
   \   000012   D253....     ADD.B   #0x1, &current_step
     75                      do_stuff();              
   \   000016   ........     CALLA   #do_stuff
     76                       
     77           	}
     78          }
   \                     ??Switch2_Process_0:
   \   00001A   1001         RETA
   \   00001C                REQUIRE _A_PJOUT_L
     79          
     80          //=========================================================================== 
     81          // Function name: Switches_Process
     82          //
     83          // Description: This function handles the detection of SW1 and SW2
     84          //
     85          // Passed : no variables passed
     86          // Locals: no variables declared
     87          // Returned: no values returned
     88          // Globals: none
     89          //
     90          // Author: Mattia Muller
     91          // Date: Sept 2013
     92          // Compiler: Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1) //===========================================================================
     93          //******************************************************************************
     94          //------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2
     95          void Switches_Process(void){
   \                     Switches_Process:
     96           Switch1_Process();
   \   000000   ........     CALLA   #Switch1_Process
     97           Switch2_Process();
   \   000004   ........     BRA     #Switch2_Process
     98          } 
     99          //------------------------------------------------------------------------------
    100          //******************************************************************************
    101          
    102          
    103          // timerA0-1,2,overflow Interrupt Vector (TAIV) handler
    104          #pragma vector=PORT4_VECTOR

   \                                 In  segment ISR_CODE, align 2
    105          __interrupt void PORT4_VECTOR_ISR(void){
   \                     PORT4_VECTOR_ISR:
   \   000000   0F12         PUSH.W  R15
    106          
    107            switch(P4IV)
   \   000002   1F423E02     MOV.W   &0x23e, R15
   \   000006   2F83         SUB.W   #0x2, R15
   \   000008   0324         JEQ     ??PORT4_VECTOR_ISR_1
   \   00000A   2F83         SUB.W   #0x2, R15
   \   00000C   0C24         JEQ     ??PORT4_VECTOR_ISR_2
   \   00000E   153C         JMP     ??PORT4_VECTOR_ISR_0
    108              {
    109                case P4IV_P4IFG0:        
    110                  disableInput();               
   \                     ??PORT4_VECTOR_ISR_1:
   \   000010   ........     CALLA   #disableInput
    111                  sw1_position = RELEASED;
   \   000014   D243....     MOV.B   #0x1, &sw1_position
    112                  okay_to_look_at_switch1 = OKAY;
   \   000018   D243....     MOV.B   #0x1, &okay_to_look_at_switch1
    113                  count_debounce_SW1 = SET_0;
   \   00001C   8243....     MOV.W   #0x0, &count_debounce_SW1
    114                  PJOUT |=LED3;
   \   000020   A2D22203     BIS.W   #0x4, &0x322
    115                  break;
   \   000024   0A3C         JMP     ??PORT4_VECTOR_ISR_0
    116                    
    117                case P4IV_P4IFG1:
    118                  disableInput();               
   \                     ??PORT4_VECTOR_ISR_2:
   \   000026   ........     CALLA   #disableInput
    119                  sw2_position = RELEASED;
   \   00002A   D243....     MOV.B   #0x1, &sw2_position
    120                  okay_to_look_at_switch2 = OKAY;
   \   00002E   D243....     MOV.B   #0x1, &okay_to_look_at_switch2
    121                  count_debounce_SW2 = SET_0;
   \   000032   8243....     MOV.W   #0x0, &count_debounce_SW2
    122                  PJOUT |=LED3;
   \   000036   A2D22203     BIS.W   #0x4, &0x322
    123                default:
    124                  break;
    125              }  
    126            
    127          
    128          }
   \                     ??PORT4_VECTOR_ISR_0:
   \   00003A   3F41         POP.W   R15
   \   00003C   0013         RETI
   \   00003E                REQUIRE _A_PJOUT_L
   \   00003E                REQUIRE P4IV
    129          // timerA0
    130          //=============================================================================
    131          
    132          
    133          //=========================================================================== 
    134          // Function name: disableInput
    135          //
    136          // Description: This function disables of SW1 and SW2
    137          //
    138          // Passed : no variables passed
    139          // Locals: no variables declared
    140          // Returned: no values returned
    141          // Globals: none
    142          //
    143          // Author: Mattia Muller
    144          // Date: Sept 2013
    145          // Compiler: Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1) //===========================================================================
    146          //******************************************************************************
    147          //------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2
    148          void disableInput(void)
   \                     disableInput:
    149          {
    150          
    151            P4IE &= ~(SW1 | SW2);                     // P4.0 interrupt disabled
   \   000000   F2F0FC003B02 AND.B   #0xfc, &0x23b
    152            P4IFG = SET_0;                            // P4 IFG cleared  
   \   000006   C2433D02     MOV.B   #0x0, &0x23d
    153          }
   \   00000A   1001         RETA
   \   00000C                REQUIRE _A_PBIE_L
   \   00000C                REQUIRE _A_PBIFG_L
    154          
    155          //=========================================================================== 
    156          // Function name: enableInput
    157          //
    158          // Description: This function enables SW1 and SW2
    159          //
    160          // Passed : no variables passed
    161          // Locals: no variables declared
    162          // Returned: no values returned
    163          // Globals: none
    164          //
    165          // Author: Mattia Muller
    166          // Date: Sept 2013
    167          // Compiler: Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1) //===========================================================================
    168          //******************************************************************************
    169          //------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2
    170          void enableInput(void)
   \                     enableInput:
    171          {
    172          
    173            P4IE |= (SW1 | SW2);                     // P4.0 interrupt disabled
   \   000000   F2D003003B02 BIS.B   #0x3, &0x23b
    174            P4IFG = SET_0;                           // P4 IFG cleared  
   \   000006   C2433D02     MOV.B   #0x0, &0x23d
    175          }
   \   00000A   1001         RETA
   \   00000C                REQUIRE _A_PBIE_L
   \   00000C                REQUIRE _A_PBIFG_L
    176          
    177          
    178          //=========================================================================== 
    179          // Function name: do_stuff
    180          //
    181          // Description: Do stuff when SW1 or SW2 are pressed
    182          //
    183          // Passed : no variables passed
    184          // Locals: no variables declared
    185          // Returned: no values returned
    186          // Globals: none
    187          //
    188          // Author: Mattia Muller
    189          // Date: Sept 2013
    190          // Compiler: Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1) //===========================================================================
    191          //******************************************************************************
    192          //------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2
    193          void do_stuff(void){
   \                     do_stuff:
    194            switch(what_to_do){
   \   000000   5E42....     MOV.B   &what_to_do, R14
   \   000004   6E83         SUB.B   #0x2, R14
   \   000006   3A24         JEQ     ??do_stuff_3
   \   000008   7E800600     SUB.B   #0x6, R14
   \   00000C   0C24         JEQ     ??do_stuff_4
   \   00000E   5E83         SUB.B   #0x1, R14
   \   000010   1624         JEQ     ??do_stuff_5
   \   000012   5E83         SUB.B   #0x1, R14
   \   000014   1224         JEQ     ??do_stuff_6
   \   000016   7E800300     SUB.B   #0x3, R14
   \   00001A   2E24         JEQ     ??do_stuff_7
   \   00001C   5E83         SUB.B   #0x1, R14
   \   00001E   4424         JEQ     ??do_stuff_2
   \   000020   5E83         SUB.B   #0x1, R14
   \   000022   4224         JEQ     ??do_stuff_2
   \   000024   1001         RETA
    195          		case CALIBRATE:
    196                            lcd_out("              ", LCD_LINE_2);
   \                     ??do_stuff_4:
   \   000026   7D40C000     MOV.B   #0xc0, R13
   \   00002A   3C40....     MOV.W   #`?<Constant "              ">`, R12
   \   00002E   ........     CALLA   #lcd_out
    197                                 IR_calibration(current_step);
   \   000032   5C42....     MOV.B   &current_step, R12
   \   000036   ........     BRA     #IR_calibration
    198                                 //char* ascii_value = itoa(current_step);            
    199                                    
    200                                 //lcd_out(ascii_value, LCD_LINE_2);     
    201                          break;
    202          		case STRAIGHT: // 1250 msec 
    203          			STRAIGHT_TIME_Process();
   \                     ??do_stuff_6:
   \   00003A   ........     BRA     #STRAIGHT_TIME_Process
    204          		break;
    205                          case PROJECT_05: // 1250 msec 
    206                                  fifty_msec_sleep_A1(SET_10);
   \                     ??do_stuff_5:
   \   00003E   3C400A00     MOV.W   #0xa, R12
   \   000042   ........     CALLA   #fifty_msec_sleep_A1
    207                                  stop = OFF;
   \   000046   C243....     MOV.B   #0x0, &stop
    208                                  straight_direction = FORWARD;
   \   00004A   D243....     MOV.B   #0x1, &straight_direction
    209                                  current_step = SET_0;
   \   00004E   C243....     MOV.B   #0x0, &current_step
    210                                  time_limit = SET_NEG_1;
   \   000052   B243....     MOV.W   #0xffff, &time_limit
    211          			what_to_do = PROJECT_05;
   \   000056   F2400900.... MOV.B   #0x9, &what_to_do
    212                                  left_wheel_count = LEFT_WHEEL_COUNT;
   \   00005C   F2401E00.... MOV.B   #0x1e, &left_wheel_count
    213           			right_wheel_count = RIGHT_WHEEL_COUNT;
   \   000062   F2401100.... MOV.B   #0x11, &right_wheel_count
    214                                  what_to_do_movement = STRAIGHT;
   \   000068   F2400A00.... MOV.B   #0xa, &what_to_do_movement
    215                                  sample = ON;
   \   00006E   D243....     MOV.B   #0x1, &sample
    216                                  black_space = OFF;
   \   000072   C243....     MOV.B   #0x0, &black_space
    217          		break;
   \   000076   1001         RETA
    218                          case THUMB_WHEEL: // 1250 msec 
    219          			CLOCK_TIME_Process();
   \                     ??do_stuff_7:
   \   000078   ........     BRA     #CLOCK_TIME_Process
    220          		break;
    221          		case SERIAL: 
    222                            if (current_step == SET_0) {
   \                     ??do_stuff_3:
   \   00007C   C293....     CMP.B   #0x0, &current_step
   \   000080   0520         JNE     ??do_stuff_8
    223                              char temp = UCA1RXBUF;
   \   000082   1F42EC05     MOV.W   &0x5ec, R15
    224                              UCA1IE |= UCTXIE;
   \   000086   A2D3FA05     BIS.W   #0x2, &0x5fa
   \   00008A   1001         RETA
    225                            } else {
    226                             // UCA1IE &= ~UCTXIE;
    227                             // UCA1IFG = SET_2;
    228                              cpu_rx_ring_wr = SET_0;
   \                     ??do_stuff_8:
   \   00008C   8243....     MOV.W   #0x0, &cpu_rx_ring_wr
    229                              cpu_rx_ring_rd = SET_0;
   \   000090   8243....     MOV.W   #0x0, &cpu_rx_ring_rd
    230                              cpu_tx_ring_wr = SET_0;
   \   000094   8243....     MOV.W   #0x0, &cpu_tx_ring_wr
    231                              cpu_tx_ring_rd = SET_0;
   \   000098   8243....     MOV.W   #0x0, &cpu_tx_ring_rd
    232                              lcd_out("               ",LCD_LINE_2);
   \   00009C   7D40C000     MOV.B   #0xc0, R13
   \   0000A0   3C40....     MOV.W   #`?<Constant "               ">`, R12
   \   0000A4   ........     CALLA   #lcd_out
    233                            }
    234          		break;
    235          		case FIGURE_8: // 1250 msec 
    236          		 	//FIGURE_8_Process();
    237          		break;
    238          		case TRIANGLE: // 1250 msec 
    239          			//TRIANGLE_Process();
    240          		break;
    241          		default: 
    242          		 	//Default_Process();
    243          		break;
    244          		}
    245            
    246            
    247          }
   \                     ??do_stuff_2:
   \   0000A8   1001         RETA
   \   0000AA                REQUIRE _A_UCA1RXBUF_L
   \   0000AA                REQUIRE _A_UCA1IE_L

   \                                 In  segment INTVEC, offset 0x40, root
   \                     `??PORT4_VECTOR_ISR??INTVEC 64`:
   \   000040   ....         DC16    PORT4_VECTOR_ISR

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for sw1_position>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for sw2_position>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "              ">`:
   \   000000   202020202020 DC8 "              "
   \            202020202020
   \            202000      

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "               ">`:
   \   000000   202020202020 DC8 "               "
   \            202020202020
   \            20202000    

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      6   PORT4_VECTOR_ISR
        6   -> disableInput
      4   Switch1_Process
        4   -> do_stuff
      4   Switch2_Process
        4   -> do_stuff
      4   Switches_Process
        4   -> Switch1_Process
        4   -> Switch2_Process
      4   disableInput
      4   do_stuff
        4   -> CLOCK_TIME_Process
        4   -> IR_calibration
        4   -> STRAIGHT_TIME_Process
        4   -> fifty_msec_sleep_A1
        4   -> lcd_out
      4   enableInput


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant "               ">
      15  ?<Constant "              ">
       1  ?<Initializer for sw1_position>
       1  ?<Initializer for sw2_position>
       2  ??PORT4_VECTOR_ISR??INTVEC 64
       2  P4IV
      62  PORT4_VECTOR_ISR
      28  Switch1_Process
      28  Switch2_Process
       8  Switches_Process
       2  _A_PBIE_L
       2  _A_PBIFG_L
       2  _A_PJOUT_L
       2  _A_UCA1IE_L
       2  _A_UCA1RXBUF_L
       2  count_debounce_SW1
       2  count_debounce_SW2
      12  disableInput
     170  do_stuff
      12  enableInput
       1  okay_to_look_at_switch1
       1  okay_to_look_at_switch2
       1  sw1_position
       1  sw2_position

 
 258 bytes in segment CODE
  12 bytes in segment DATA16_AN
  31 bytes in segment DATA16_C
   2 bytes in segment DATA16_I
   2 bytes in segment DATA16_ID
   6 bytes in segment DATA16_Z
   2 bytes in segment INTVEC
  62 bytes in segment ISR_CODE
 
 320 bytes of CODE  memory
  33 bytes of CONST memory (+  2 bytes shared)
   8 bytes of DATA  memory (+ 12 bytes shared)

Errors: none
Warnings: none
