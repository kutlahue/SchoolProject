###############################################################################
#
# IAR C/C++ Compiler V6.10.2.50871/W32 for MSP430         30/Oct/2014  18:31:02
# Copyright 1996-2014 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.10
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        E:\Fall 14\ECE 306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\serial.c
#    Command line  =  
#        "E:\Fall 14\ECE 306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\serial.c" -lC
#        "E:\Fall 14\ECE 306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\Debug\List\"
#        -o "E:\Fall 14\ECE 306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\Debug\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR5739__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.0\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -Ol --multiplier=32
#        --multiplier_location=4C0 --hw_workaround=CPU40 --hw_workaround=CPU39
#        --code_model=large
#    List file     =  
#        E:\Fall 14\ECE
#        306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\Debug\List\serial.lst
#    Object file   =  
#        E:\Fall 14\ECE
#        306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\Debug\Obj\serial.r43
#
###############################################################################

E:\Fall 14\ECE 306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\serial.c
      1          //------------------------------------------------------------------------------
      2          //  File Name: serial.c
      3          //
      4          //  Description: This file contains the serial communication functions
      5          //
      6          //  Mattia Muller
      7          //  Oct 2013
      8          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1)
      9          //------------------------------------------------------------------------------
     10          
     11          //------------------------------------------------------------------------------
     12          #include  "msp430.h"

   \                                 In  segment DATA16_AN, at 0x322
   \   union <unnamed> _A_PJOUT_L
   \                     _A_PJOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5e0
   \   union <unnamed> _A_UCA1CTLW0_L
   \                     _A_UCA1CTLW0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5e6
   \   union <unnamed> _A_UCA1BRW_L
   \                     _A_UCA1BRW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5e8
   \   union <unnamed> _A_UCA1MCTLW_L
   \                     _A_UCA1MCTLW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5ec
   \   union <unnamed> _A_UCA1RXBUF_L
   \                     _A_UCA1RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5ee
   \   union <unnamed> _A_UCA1TXBUF_L
   \                     _A_UCA1TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5fa
   \   union <unnamed> _A_UCA1IE_L
   \                     _A_UCA1IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5fe
   \   unsigned short volatile UCA1IV
   \                     UCA1IV:
   \   000000                DS8 2
     13          #include  "functions.h"
     14          #include  "macros.h"

  #define Z                    (0x04) // Port 3 Pin 2 offset
          ^
"E:\Fall 14\ECE 306\WORKSPACE\SCHOOLPROJECT\HOMEWORK_08\macros.h",58  Warning[Pe047]: 
          incompatible redefinition of macro "Z" (declared at line 149 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench
          7.0\430\inc\msp430fr5739.h")
     15          

   \                                 In  segment DATA16_C, align 1, align-sorted
     16          const char string[] = "NCSU #1";
   \                     string:
   \   000000   4E4353552023 DC8 "NCSU #1"
   \            3100        
     17          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          unsigned int usb_rx_ring_wr, usb_rx_ring_rd, usb_tx_ring_wr, usb_tx_ring_rd, i;
   \                     usb_rx_ring_wr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     usb_rx_ring_rd:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     usb_tx_ring_wr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     usb_tx_ring_rd:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     i:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          char* USB_Char_Rx;
   \                     USB_Char_Rx:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     20          char* USB_Char_Tx;
   \                     USB_Char_Tx:
   \   000000                DS8 2
     21          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     22          char reception[16];
   \                     reception:
   \   000000                DS8 16
     23          
     24          //---------------------------------------------------------------------------- 

   \                                 In  segment CODE, align 2
     25          void Init_Serial_UCA1(void){
   \                     Init_Serial_UCA1:
   \   000000   2183         SUB.W   #0x2, SP
     26          volatile int i;
     27          
     28          for(i=SET_0; i<SMALL_RING_SIZE; i++){
   \   000002   81430000     MOV.W   #0x0, 0(SP)
   \   000006   093C         JMP     ??Init_Serial_UCA1_2
     29            USB_Char_Rx[i] = SET_0;       // USB Character
   \                     ??Init_Serial_UCA1_0:
   \   000008   1F42....     MOV.W   &USB_Char_Rx, R15
   \   00000C   2F51         ADD.W   @SP, R15
   \   00000E   CF430000     MOV.B   #0x0, 0(R15)
     30            }
   \   000012   2F41         MOV.W   @SP, R15
   \   000014   1F53         ADD.W   #0x1, R15
   \   000016   814F0000     MOV.W   R15, 0(SP)
   \                     ??Init_Serial_UCA1_2:
   \   00001A   B19007000000 CMP.W   #0x7, 0(SP)
   \   000020   F33B         JL      ??Init_Serial_UCA1_0
     31            usb_rx_ring_wr = SET_0;
   \   000022   8243....     MOV.W   #0x0, &usb_rx_ring_wr
     32            usb_rx_ring_rd = SET_0;
   \   000026   8243....     MOV.W   #0x0, &usb_rx_ring_rd
     33          
     34          for(i=SET_0; i<LARGE_RING_SIZE; i++){ 
   \   00002A   81430000     MOV.W   #0x0, 0(SP)
   \   00002E   093C         JMP     ??Init_Serial_UCA1_3
     35              USB_Char_Tx[i] = SET_0;     // USB Character
   \                     ??Init_Serial_UCA1_1:
   \   000030   1F42....     MOV.W   &USB_Char_Tx, R15
   \   000034   2F51         ADD.W   @SP, R15
   \   000036   CF430000     MOV.B   #0x0, 0(R15)
     36            }
   \   00003A   2F41         MOV.W   @SP, R15
   \   00003C   1F53         ADD.W   #0x1, R15
   \   00003E   814F0000     MOV.W   R15, 0(SP)
   \                     ??Init_Serial_UCA1_3:
   \   000042   B1920000     CMP.W   #0x8, 0(SP)
   \   000046   F43B         JL      ??Init_Serial_UCA1_1
     37            usb_tx_ring_wr = SET_0;
   \   000048   8243....     MOV.W   #0x0, &usb_tx_ring_wr
     38            usb_tx_ring_rd = SET_0;
   \   00004C   8243....     MOV.W   #0x0, &usb_tx_ring_rd
     39            
     40          // Configure UART 0
     41          UCA1CTLW0 = SET_0; // Use word register 
   \   000050   8243E005     MOV.W   #0x0, &0x5e0
     42          UCA1CTLW0 |= UCSSEL__SMCLK; // Set SMCLK as fBRCLK 
   \   000054   B2D08000E005 BIS.W   #0x80, &0x5e0
     43          UCA1CTLW0 |= UCSWRST; // Set Software reset enable
   \   00005A   92D3E005     BIS.W   #0x1, &0x5e0
     44          
     45          
     46          // 9,600 Baud Rate
     47          // 1. Calculate N = fBRCLK/Baudrate [if N > 16 continue with step 3, otherwise with step 2] 
     48          // N = SMCLK / 4,800 => 8,000,000 / 4,800 = 1666.6666
     49          // 2. OS16 = 0, UCBRx = INT(N) [continue with step 4]
     50          // 3. OS16 = 1, UCx = INT(N/16), UCFx = INT([(N/16) – INT(N/16)] × 16)
     51          // UCx = INT(N/16) = 1666.66666/16 => 104
     52          // UCFx = INT([(N/16) – INT(N/16)] × 16) = ([1666.66666/16-INT(1666.66666/16)]*16) => (104.0208333-52)*16=>0.0208333*16=0.3333
     53          // 4. UCSx can be found by looking up the fractional part of N ( = N - INT(N) ) in Table 18-4
     54          // Decicmal of SMCLK / 8,000,000 / 9,600 = 1666.66666 => 0.666 yields 0xD6
     55          // 5. If OS16 = 0 was chosen, a detailed error calculation is recommended to be performed
     56          // 
     57          //                                        TX error (%) RX error (%) 
     58          // BRCLK   Baudrate UCOS16  UCBRx  UCFx   UCSx   neg    pos   neg    pos 
     59          // 8000000 4800     1       104     0      0xD6   -0.08  0.04  -0.10  0.14
     60          UCA1BRW = 104 ; // 4,800 baud
   \   00005E   B2406800E605 MOV.W   #0x68, &0x5e6
     61          // UCA0MCTLW = UCSx concatenate UCFx concatenate UCOS16;
     62          // UCA0MCTLW = 0xD6 concatenate 1 concatenate 1;
     63          UCA1MCTLW = 0xD621 ;
   \   000064   B24021D6E805 MOV.W   #0xd621, &0x5e8
     64          UCA1CTL1 &= ~UCSWRST; // Release from reset 
   \   00006A   D2C3E005     BIC.B   #0x1, &0x5e0
     65          UCA1IE |= UCRXIE; // Enable RX interrupt
   \   00006E   92D3FA05     BIS.W   #0x1, &0x5fa
     66          //UCA0IE |= UCTXIE;
     67          
     68          }
   \   000072   2153         ADD.W   #0x2, SP
   \   000074   1001         RETA
   \   000076                REQUIRE _A_UCA1CTLW0_L
   \   000076                REQUIRE _A_UCA1BRW_L
   \   000076                REQUIRE _A_UCA1MCTLW_L
   \   000076                REQUIRE _A_UCA1IE_L
     69          
     70          
     71          

   \                                 In  segment CODE, align 2
     72          void uart_send_byte( unsigned char data ) {
   \                     uart_send_byte:
     73            
     74            //data <<= SET_1;
     75              // Wait until USCI_A0 TX buffer is ready
     76            while (!(SET_2&UCTXIFG)) ;
     77              // Send the byte
     78              UCA1TXBUF = data;
   \   000000   4C4C         MOV.B   R12, R12
   \   000002   824CEE05     MOV.W   R12, &0x5ee
     79          }
   \   000006   1001         RETA
   \   000008                REQUIRE _A_UCA1TXBUF_L
     80          
     81          
     82          
     83          //------------------------------------------------------------------------------ 
     84          #pragma vector=USCI_A1_VECTOR

   \                                 In  segment ISR_CODE, align 2
     85          __interrupt void USCI_A1_ISR(void){
   \                     USCI_A1_ISR:
   \   000000   1F15         PUSHM.W #0x2, R15
     86          unsigned int temp;
                              ^
Warning[Pe177]: variable "temp" was declared but never referenced
     87          switch(__even_in_range(UCA1IV,0x08)){
   \   000002   1F42FE05     MOV.W   &0x5fe, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for USCI_A1_ISR>_0`:
   \   000008   303C         JMP     ??USCI_A1_ISR_0
   \   00000A   033C         JMP     ??USCI_A1_ISR_3
   \   00000C   243C         JMP     ??USCI_A1_ISR_4
   \   00000E   2D3C         JMP     ??USCI_A1_ISR_0
   \   000010   2C3C         JMP     ??USCI_A1_ISR_0
     88              case 0: // Vector 0 - no interrupt
     89                break;
     90              case 2: // Vector 2 - RXIFG
     91                /*
     92                temp = usb_rx_ring_wr++; 
     93                USB_Char_Rx[temp] = UCA0RXBUF; // RX -> USB_Char_Rx character
     94                if (usb_rx_ring_wr >= (SMALL_RING_SIZE)){
     95                  usb_rx_ring_wr = BEGINNING; // Circular buffer back to beginning
     96                }
     97                */
     98                PJOUT |= LED3; 
   \                     ??USCI_A1_ISR_3:
   \   000012   A2D22203     BIS.W   #0x4, &0x322
     99                if (i < (sizeof string - SET_NEG_1)) {
   \   000016   B2900900.... CMP.W   #0x9, &i
   \   00001C   192C         JC      ??USCI_A1_ISR_1
    100                  if (UCA1RXBUF == string[i] ) {
   \   00001E   1F42....     MOV.W   &i, R15
   \   000022   5F4F....     MOV.B   string(R15), R15
   \   000026   4F4F         MOV.B   R15, R15
   \   000028   829FEC05     CMP.W   R15, &0x5ec
   \   00002C   1120         JNE     ??USCI_A1_ISR_1
    101                      UCA1TXBUF = string[i++];
   \   00002E   1F42....     MOV.W   &i, R15
   \   000032   5F4F....     MOV.B   string(R15), R15
   \   000036   4F4F         MOV.B   R15, R15
   \   000038   824FEE05     MOV.W   R15, &0x5ee
   \   00003C   9253....     ADD.W   #0x1, &i
    102                      reception[i] = UCA1RXBUF;
   \   000040   1E42EC05     MOV.W   &0x5ec, R14
   \   000044   1F42....     MOV.W   &i, R15
   \   000048   CF4E....     MOV.B   R14, reception(R15)
    103                      i++;
   \   00004C   9253....     ADD.W   #0x1, &i
    104                  }
    105                }
    106                
    107                    PJOUT &= ~LED3;
   \                     ??USCI_A1_ISR_1:
   \   000050   A2C22203     BIC.W   #0x4, &0x322
    108                break;
   \   000054   0A3C         JMP     ??USCI_A1_ISR_0
    109              case 4: // Vector 4 – TXIFG 
    110               
    111                PJOUT |= LED2;
   \                     ??USCI_A1_ISR_4:
   \   000056   A2D32203     BIS.W   #0x2, &0x322
    112               // UCA1TXBUF = string[i++]; // TX next character 
    113              
    114                if (i == sizeof string - 1){ // TX over? 
   \   00005A   B2900700.... CMP.W   #0x7, &i
   \   000060   0220         JNE     ??USCI_A1_ISR_2
    115                  //UCA1IE &= ~UCTXIE; // Disable USCI_A0 TX interrupt 
    116                  i=0;
   \   000062   8243....     MOV.W   #0x0, &i
    117                }
    118                PJOUT &= ~LED2;
   \                     ??USCI_A1_ISR_2:
   \   000066   A2C32203     BIC.W   #0x2, &0x322
    119                break;
    120              default: break;
    121            } 
    122          }
   \                     ??USCI_A1_ISR_0:
   \   00006A   1E17         POPM.W  #0x2, R15
   \   00006C   0013         RETI
   \   00006E                REQUIRE _A_PJOUT_L
   \   00006E                REQUIRE _A_UCA1RXBUF_L
   \   00006E                REQUIRE _A_UCA1TXBUF_L
   \   00006E                REQUIRE UCA1IV

   \                                 In  segment INTVEC, offset 0x56, root
   \                     `??USCI_A1_ISR??INTVEC 86`:
   \   000056   ....         DC16    USCI_A1_ISR
    123          //------------------------------------------------------------------------------
    124          
    125          
    126          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      6   Init_Serial_UCA1
      8   USCI_A1_ISR
      4   uart_send_byte


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ??USCI_A1_ISR??INTVEC 86
     118  Init_Serial_UCA1
       2  UCA1IV
       2  USB_Char_Rx
       2  USB_Char_Tx
     110  USCI_A1_ISR
       2  _A_PJOUT_L
       2  _A_UCA1BRW_L
       2  _A_UCA1CTLW0_L
       2  _A_UCA1IE_L
       2  _A_UCA1MCTLW_L
       2  _A_UCA1RXBUF_L
       2  _A_UCA1TXBUF_L
       2  i
      16  reception
       8  string
       8  uart_send_byte
       2  usb_rx_ring_rd
       2  usb_rx_ring_wr
       2  usb_tx_ring_rd
       2  usb_tx_ring_wr

 
 126 bytes in segment CODE
  16 bytes in segment DATA16_AN
   8 bytes in segment DATA16_C
  30 bytes in segment DATA16_Z
   2 bytes in segment INTVEC
 110 bytes in segment ISR_CODE
 
 236 bytes of CODE  memory
   8 bytes of CONST memory (+  2 bytes shared)
  30 bytes of DATA  memory (+ 16 bytes shared)

Errors: none
Warnings: 2
